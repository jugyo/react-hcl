import { join, resolve } from "node:path";
import type {
  GeneratedNestedBlockSchema,
  GeneratedOutputFile,
  GeneratedTypeSchema,
  NormalizedProviderSchema,
  ValueType,
} from "../types";

function toPascalCase(input: string): string {
  return input
    .split(/[^a-zA-Z0-9]+/)
    .filter((token) => token.length > 0)
    .map((token) => token[0].toUpperCase() + token.slice(1))
    .join("");
}

function valueTypeToTs(valueType: ValueType): string {
  switch (valueType) {
    case "string":
      return "TerraformScalar<string>";
    case "number":
      return "TerraformScalar<number>";
    case "bool":
      return "TerraformScalar<boolean>";
    case "list":
    case "set":
      return "unknown[] | TerraformExpression";
    case "map":
    case "object":
      return "Record<string, unknown> | TerraformExpression";
    case "any":
      return "unknown";
  }
}

function renderBlockPropsType(
  schema: GeneratedNestedBlockSchema,
  indent: string,
): string {
  const lines: string[] = ["{"];
  const nextIndent = `${indent}  `;

  for (const [name, attribute] of Object.entries(schema.attributes)) {
    const optional =
      attribute.required === true && attribute.computed !== true ? "" : "?";
    lines.push(
      `${nextIndent}${JSON.stringify(name)}${optional}: ${valueTypeToTs(attribute.valueType)};`,
    );
  }

  const nestedBlocks = schema.blocks ?? {};
  for (const [name, nestedSchema] of Object.entries(nestedBlocks)) {
    const nestedType = renderNestedBlockPropType(nestedSchema, nextIndent);
    lines.push(`${nextIndent}${JSON.stringify(name)}?: ${nestedType};`);
  }

  lines.push(`${indent}}`);
  return lines.join("\n");
}

function renderNestedBlockPropType(
  schema: GeneratedNestedBlockSchema,
  indent: string,
): string {
  const blockType = renderBlockPropsType(schema, indent);
  return `TerraformNestedBlock<${blockType}>`;
}

function renderTypeAliasBody(schema: GeneratedTypeSchema): string {
  const lines: string[] = ["{"];

  for (const [name, attribute] of Object.entries(schema.attributes)) {
    const optional =
      attribute.required === true && attribute.computed !== true ? "" : "?";
    lines.push(
      `  ${JSON.stringify(name)}${optional}: ${valueTypeToTs(attribute.valueType)};`,
    );
  }

  for (const [name, blockSchema] of Object.entries(schema.blocks)) {
    const nestedType = renderNestedBlockPropType(blockSchema, "  ");
    lines.push(`  ${JSON.stringify(name)}?: ${nestedType};`);
  }

  lines.push("}");
  return lines.join("\n");
}

function renderResourceTypeName(terraformType: string): string {
  return `${toPascalCase(terraformType)}ResourceProps`;
}

function renderDataTypeName(terraformType: string): string {
  return `${toPascalCase(terraformType)}DataProps`;
}

function renderGeneratedHeader(): string {
  return [
    "// This file is generated by `react-hcl init`.",
    "// Do not edit this file manually.",
    "",
  ].join("\n");
}

function renderTypeFile(options: {
  exportTypeName: string;
  schema: GeneratedTypeSchema;
}): string {
  const { exportTypeName, schema } = options;
  const body = renderTypeAliasBody(schema);

  return [
    renderGeneratedHeader(),
    'import type { RefExpression } from "react-hcl";',
    "",
    "type TerraformExpression = RefExpression | { value: string; toString(): string };",
    "type TerraformScalar<T> = T | TerraformExpression;",
    "type TerraformNestedBlock<T> = T | Array<T> | TerraformExpression;",
    "",
    `export type ${exportTypeName} = ${body};`,
    "",
  ].join("\n");
}

function renderAugmentationFile(options: {
  resourceTypes: string[];
  dataTypes: string[];
}): string {
  const resourceImports = options.resourceTypes.map((type) => {
    const alias = renderResourceTypeName(type);
    return `import type { ${alias} } from "./resource/${type}.generated";`;
  });
  const dataImports = options.dataTypes.map((type) => {
    const alias = renderDataTypeName(type);
    return `import type { ${alias} } from "./data/${type}.generated";`;
  });

  const resourceMapLines = options.resourceTypes.map(
    (type) => `  ${JSON.stringify(type)}: ${renderResourceTypeName(type)};`,
  );
  const dataMapLines = options.dataTypes.map(
    (type) => `  ${JSON.stringify(type)}: ${renderDataTypeName(type)};`,
  );

  return [
    renderGeneratedHeader(),
    ...resourceImports,
    ...dataImports,
    'import type { AwsProviderProps } from "./provider.generated";',
    'import "react-hcl";',
    "",
    'declare module "react-hcl" {',
    "  interface ReactHclSchemaMode {",
    // This marker flips core component props into strict schema mode.
    "    __strictSchema: true;",
    "  }",
    "",
    "  interface ResourceTypeMap {",
    ...resourceMapLines,
    "  }",
    "",
    "  interface DataTypeMap {",
    ...dataMapLines,
    "  }",
    "",
    "  interface ProviderTypeMap {",
    '    aws: Omit<AwsProviderProps, "alias">;',
    "  }",
    "}",
    "",
  ].join("\n");
}

export function buildGeneratedFiles(
  schema: NormalizedProviderSchema,
): GeneratedOutputFile[] {
  const baseDir = resolve(process.cwd(), ".react-hcl", "gen");
  const resourceTypes = Object.keys(schema.resourceSchemas);
  const dataTypes = Object.keys(schema.dataSchemas);
  const files: GeneratedOutputFile[] = [];

  for (const type of resourceTypes) {
    files.push({
      path: join(baseDir, "aws", "resource", `${type}.generated.d.ts`),
      content: renderTypeFile({
        exportTypeName: renderResourceTypeName(type),
        schema: schema.resourceSchemas[type],
      }),
    });
  }

  for (const type of dataTypes) {
    files.push({
      path: join(baseDir, "aws", "data", `${type}.generated.d.ts`),
      content: renderTypeFile({
        exportTypeName: renderDataTypeName(type),
        schema: schema.dataSchemas[type],
      }),
    });
  }

  files.push({
    path: join(baseDir, "aws", "provider.generated.d.ts"),
    content: renderTypeFile({
      exportTypeName: "AwsProviderProps",
      schema: schema.providerSchema,
    }),
  });

  files.push({
    path: join(baseDir, "aws", "index.generated.d.ts"),
    content: renderAugmentationFile({
      resourceTypes,
      dataTypes,
    }),
  });

  return files.sort((a, b) => a.path.localeCompare(b.path));
}
